#version 330

#define PI 3.14159265358979323846
#define TWO_PI 2*PI
#define CLAMP1(x) clamp(0,1,x)
#define SVALUE(x) -1.+2.*x
#define UVALUE(x) .5+.5*x

struct Rect{vec2 pos, siz;};

struct Bounds{vec2 xrange, yrange;};

struct View
{
    vec4 map; //xy=uv, z=sdf, w=mask
    Rect window;
    Bounds margin;
};

struct Channel
{
    sampler2D tex;
    vec2 siz;
};

struct Page
{
    int tracks;
    int bandguard;
    Bounds margin;
};

in vec2 texCoord;
uniform Page page;
uniform Rect screen;
uniform Rect window;
uniform Channel channel0;
uniform Channel channel1;
uniform Channel channel2;
uniform Channel channel3;
out vec4 fragOut;

float osc_triangle(float t, float f)
{
    float a, b, c;
    // 2x ramp 1/2
    a = 2.*fract(t*f); 
    // bias
    b = SVALUE(floor(a));
    // 2x ramp 1/4
    c = SVALUE(fract(a));

    return b*(1.-abs(c));
}

float osc_rectangle(float t, float f, float d)
{
    return smoothstep(-d, d, osc_triangle(t, f));
}
//Returns: sdf
float sd_square(vec2 uv)
{
    uv = abs(SVALUE(uv));
    return max(uv.x,uv.y);
}
//Returns: vec4(xy=uv, z=sdf, w=mask)
vec4 sd_rect(vec2 uv, Rect src, Rect dst)
{
    uv *= dst.siz;
    uv -= src.pos;
    uv /= src.siz;

    float sd = sd_square(uv);

    return vec4(uv, sd, step(sd,1));
}
//Returns: vec4(xy=uv, z=sdf, w=mask)
vec4 sd_bounds(vec2 uv, Rect r, Bounds b)
{
    vec2 kmin = vec2(b.xrange.x, b.yrange.x);
    vec2 kmax = vec2(b.xrange.y, b.yrange.y);

    vec2 bsize = r.siz - kmin + kmax;
    //vec2 bsize = r.siz - kmax * 2;
    
    uv *= r.siz;
    uv -= kmin;
    uv /= bsize;

    float sd = sd_square(uv);

    return vec4(uv, sd, step(sd,1));
}

Rect view_add_bounds(Rect r, Bounds b)
{   
    vec2 kmin = vec2(b.xrange.x, b.yrange.x);
    vec2 kmax = vec2(b.xrange.y, b.yrange.y);
    r.pos += kmin;
    r.siz -= kmin+kmax;
    return r;
}

View view_get_root(vec2 uv)
{
    View view;
    //view.margin.xrange = vec2(10,10);
    //view.margin.yrange = vec2(10,10);
    view.window.siz = vec2(window.siz);
    view.map = sd_rect(uv, view_add_bounds(view.window, view.margin), view.window);
    return view;
}

vec4 view_get_map(View src, View dst)
{
    vec4 o = sd_rect(dst.map.xy, view_add_bounds(src.window, src.margin), dst.window);
    o.w *= dst.map.w;
    return o;
}

vec4 tracks_sdf(View view, int count, int bandguard)
{
    vec4 o;
    vec2 uv = view.map.xy;
    // coord map
    o.xy = fract(uv * vec2(1,count));
    o.y = abs(SVALUE(o.y));

    // index map
    o.z = floor(dot(uv,vec2(0,1)) * count);
    o.z /= count;
    // track mask
    o.w = view.map.w;
    // bandguard mask
    float q0 = 1/(view.window.siz.y/count/2);
    q0*=bandguard;
    o.w *= step(o.y,1-q0);
    return o;
}

float smoothstep2(float x, float y, float d)
{
    return smoothstep(x-d, x+d, y);
}

vec4 tracks_main(vec2 uv)
{
    //int tracks = 32; // units
    //int bandguard = 10; // pixels

    View v0,v1,v2;

    v0 = view_get_root(uv);
    v1 = v0;
    v2 = v0;

    v1.margin.xrange = page.margin.xrange;
    v1.margin.yrange = page.margin.yrange;
    //v1.margin = page.margin;
    //bounds_copy(page.margin, v1.margin);
    v1.map = view_get_map(v1, v0);

    v2.margin.xrange = vec2(page.bandguard);
    v2.margin.yrange = vec2(page.bandguard/2);
    v2.map = view_get_map(v2, v1);

    vec4 map = tracks_sdf(v2, page.tracks, page.bandguard/2);

    float wave = texture(channel0.tex, map.xz).r;
    //float wave = texture(channel0.tex, map.xz*vec2(.15,0)).r;
    wave *= 0.85;

    float d = page.tracks/window.siz.x;
    wave = smoothstep2(wave,map.y,d*10.);

    //wave = step(wave,map.y);
    return  vec4(vec3(wave)*map.w, v1.map.w);
}
//
vec4 grid_main(vec2 uv, float freq)
{
    uv.y *= window.siz.y/window.siz.x;

    //freq = window.siz.x/freq;

    float d = freq/window.siz.x;
    vec4 o;
    vec2 clk;

    float d0 = d*4;
    clk.x = osc_rectangle(uv.x, freq, d0);
    clk.y = osc_rectangle(uv.y, freq, d0);

    //o.xy = clk;
    o.z = max(clk.x,clk.y)-min(clk.x,clk.y);
    o.w = 1;
    
    return o;
}
//
void main()
{
    vec2 uv = gl_FragCoord.xy / window.siz.xy;

    vec4 color,c0,c1;

    //c0 = grid_main(uv,10);
    c0 = vec4(0.8,0,0,1);
    c1 = tracks_main(uv);

    color = mix(c0,c1,c1.a);
   
    fragOut = color;
}